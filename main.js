/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TickTocPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  showLastModified: false,
  showTimeToRead: false,
  wordsPerMinute: 200,
  listStyle: "bullet",
  dateFormat: "iso"
};
var TickTocPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new TickTocSettingTab(this.app, this));
      this.addRibbonIcon("list-restart", "Refresh TOC", (evt) => {
        this.refreshAllTOCs();
      });
      this.addCommand({
        id: "create-toc",
        name: "Insert TOC under first header",
        editorCallback: (editor) => {
          const content = editor.getValue();
          const lines = content.split("\n");
          let firstHeaderIndex = -1;
          let tagEndIndex = -1;
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].startsWith("#") && !lines[i].includes("Table of Contents")) {
              firstHeaderIndex = i;
              tagEndIndex = i + 1;
              break;
            }
          }
          if (firstHeaderIndex === -1) {
            new import_obsidian.Notice("No header found in document");
            return;
          }
          while (tagEndIndex < lines.length) {
            const line = lines[tagEndIndex].trim();
            if (line.match(/#[a-zA-Z0-9_-]+/) || line === "") {
              tagEndIndex++;
            } else {
              break;
            }
          }
          let insertPosition = tagEndIndex;
          if (insertPosition < lines.length && lines[insertPosition].startsWith("#")) {
            insertPosition--;
          }
          if (insertPosition < lines.length && lines[insertPosition].trim() === "## Table of Contents") {
            new import_obsidian.Notice("TOC already exists after first header");
            return;
          }
          const toc = this.generateTOC(content);
          editor.replaceRange(
            "\n" + toc,
            { line: insertPosition, ch: 0 }
          );
        }
      });
      this.addCommand({
        id: "remove-toc",
        name: "Remove TOC",
        editorCallback: (editor) => {
          this.removeTOC(editor);
        }
      });
      this.addCommand({
        id: "convert-toc-to-bullet",
        name: "Convert TOC to Bullet List",
        editorCallback: (editor) => __async(this, null, function* () {
          this.settings.listStyle = "bullet";
          yield this.saveSettings();
          this.refreshAllTOCs();
        })
      });
      this.addCommand({
        id: "convert-toc-to-number",
        name: "Convert TOC to Numbered List",
        editorCallback: (editor) => __async(this, null, function* () {
          this.settings.listStyle = "number";
          yield this.saveSettings();
          this.refreshAllTOCs();
        })
      });
      this.addCommand({
        id: "toggle-read-time",
        name: "Toggle Read Time Estimates",
        editorCallback: (editor) => __async(this, null, function* () {
          this.settings.showTimeToRead = !this.settings.showTimeToRead;
          yield this.saveSettings();
          this.refreshAllTOCs();
          new import_obsidian.Notice(`Read time estimates ${this.settings.showTimeToRead ? "enabled" : "disabled"}`);
        })
      });
      this.addCommand({
        id: "toggle-last-updated",
        name: "Toggle Last Updated Timestamps",
        editorCallback: (editor) => __async(this, null, function* () {
          this.settings.showLastModified = !this.settings.showLastModified;
          yield this.saveSettings();
          this.refreshAllTOCs();
          new import_obsidian.Notice(`Last updated timestamps ${this.settings.showLastModified ? "enabled" : "disabled"}`);
        })
      });
      this.registerEvent(
        this.app.workspace.on("editor-change", (editor, view) => {
          const cursorPosition = editor.getCursor();
          const line = editor.getLine(cursorPosition.line);
          if (line.includes("{{toc}}")) {
            const start = line.indexOf("{{toc}}");
            const end = start + "{{toc}}".length;
            editor.replaceRange(
              "",
              { line: cursorPosition.line, ch: start },
              { line: cursorPosition.line, ch: end }
            );
            const toc = this.generateTOC(editor.getValue());
            editor.replaceRange(
              toc,
              { line: cursorPosition.line, ch: start }
            );
          }
        })
      );
    });
  }
  findTOCRange(editor) {
    const content = editor.getValue();
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim() === "## Table of Contents") {
        let endIndex = i + 1;
        if (endIndex < lines.length && lines[endIndex].trim().startsWith("*Last modified:")) {
          endIndex++;
        }
        if (endIndex < lines.length && lines[endIndex].trim() === "") {
          endIndex++;
        }
        while (endIndex < lines.length) {
          const line = lines[endIndex].trim();
          if (line === "" && endIndex + 1 < lines.length && !lines[endIndex + 1].trim().startsWith("-") && !lines[endIndex + 1].trim().match(/^\d+\./)) {
            break;
          }
          if (line.startsWith("#")) {
            break;
          }
          if (line.startsWith("-") || line.match(/^\d+\./) || line === "") {
            endIndex++;
          } else {
            break;
          }
        }
        return { start: i, end: endIndex };
      }
    }
    return null;
  }
  removeTOC(editor) {
    const tocRange = this.findTOCRange(editor);
    if (tocRange) {
      const content = editor.getValue();
      const lines = content.split("\n");
      const newContent = [
        ...lines.slice(0, tocRange.start),
        ...lines.slice(tocRange.end)
      ].join("\n");
      editor.setValue(newContent);
      new import_obsidian.Notice("TOC removed");
    } else {
      new import_obsidian.Notice("No TOC found in current file");
    }
  }
  refreshAllTOCs() {
    return __async(this, null, function* () {
      const activeLeaf = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeLeaf) {
        new import_obsidian.Notice("No active markdown file");
        return;
      }
      const editor = activeLeaf.editor;
      const tocRange = this.findTOCRange(editor);
      if (tocRange) {
        const content = editor.getValue();
        const lines = content.split("\n");
        const beforeTOC = lines.slice(0, tocRange.start).join("\n");
        const afterTOC = lines.slice(tocRange.end).join("\n");
        const newTOC = this.generateTOC(beforeTOC + "\n" + afterTOC);
        editor.setValue(beforeTOC + "\n" + newTOC + afterTOC);
        new import_obsidian.Notice("TOC refreshed");
      } else {
        new import_obsidian.Notice("No TOC found in current file");
      }
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  generateTOC(content) {
    const lines = content.split("\n");
    const headers = [];
    let levelNumbers = [];
    for (let i = 0; i < lines.length; i++) {
      const match = lines[i].match(/^(#{1,6})\s(.+)/);
      if (match) {
        if (match[2].trim() === "Table of Contents")
          continue;
        const level = match[1].length;
        if (level > levelNumbers.length) {
          while (levelNumbers.length < level) {
            levelNumbers.push(0);
          }
        } else if (level < levelNumbers.length) {
          levelNumbers = levelNumbers.slice(0, level);
        }
        levelNumbers[level - 1]++;
        headers.push({
          level,
          text: match[2].trim(),
          line: i,
          contentUntilNext: "",
          numberingPath: [...levelNumbers]
        });
      }
    }
    for (let i = 0; i < headers.length; i++) {
      const startLine = headers[i].line + 1;
      const endLine = i < headers.length - 1 ? headers[i + 1].line : lines.length;
      headers[i].contentUntilNext = lines.slice(startLine, endLine).join("\n");
    }
    if (headers.length === 0) {
      return "";
    }
    let toc = "## Table of Contents\n";
    if (this.settings.showLastModified) {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        const lastModified = activeFile.stat.mtime;
        const formattedTime = this.settings.dateFormat === "iso" ? new Date(lastModified).toISOString() : new Date(lastModified).toLocaleString();
        toc += `*Last modified: ${formattedTime}*
`;
      }
    }
    toc += "\n";
    headers.forEach((header) => {
      const indent = "  ".repeat(header.level - 1);
      const link = this.createHeaderLink(header.text);
      let prefix = this.settings.listStyle === "number" ? `${header.numberingPath.join(".")}. ` : `- `;
      let entry = `${indent}${prefix}[[#${link}|${header.text}]]`;
      if (this.settings.showTimeToRead && header.contentUntilNext) {
        const timeToRead = this.calculateTimeToRead(header.contentUntilNext);
        if (timeToRead > 0) {
          entry += ` *(${timeToRead} min read)*`;
        }
      }
      toc += entry + "\n";
    });
    return toc;
  }
  calculateTimeToRead(content) {
    const words = content.trim().split(/\s+/).length;
    const minutes = Math.ceil(words / this.settings.wordsPerMinute);
    return minutes;
  }
  getLastModified() {
    const date = /* @__PURE__ */ new Date();
    if (this.settings.dateFormat === "iso") {
      return date.toISOString();
    }
    return date.toLocaleDateString() + " " + date.toLocaleTimeString();
  }
  createHeaderLink(headerText) {
    return headerText.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-");
  }
};
var TickTocSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("List Style").setDesc("Choose list style for table of contents").addDropdown((dropdown) => dropdown.addOption("bullet", "Bullet List").addOption("number", "Numbered List").setValue(this.plugin.settings.listStyle).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.listStyle = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Date Format").setDesc("Choose between ISO 8601 or locale-specific date format").addDropdown((dropdown) => dropdown.addOption("iso", "ISO 8601").addOption("locale", "Locale Format").setValue(this.plugin.settings.dateFormat).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.dateFormat = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Show Last Modified").setDesc("Add last modified timestamp to each section").addToggle((toggle) => toggle.setValue(this.plugin.settings.showLastModified).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showLastModified = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Show Time to Read").setDesc("Add estimated reading time for each section").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTimeToRead).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showTimeToRead = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Words Per Minute").setDesc("Average reading speed for time estimates").addSlider((slider) => slider.setLimits(100, 400, 25).setValue(this.plugin.settings.wordsPerMinute).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.settings.wordsPerMinute = value;
      yield this.plugin.saveSettings();
    })));
  }
};
